<%namespace name="common" file="/codegen_common.tpl"/><%
    # Python code here
%><?php
/**
 * Mongo Service from schema: ${ model['schema-name'] } version ${ model['version'] }
 * Code generated by ${params['TASK_TYPE_NAME']}
 *
 */

namespace Service;

% for entity_name, entity_def in model['entities'].iteritems():
/**
 * Service class that provides business logic for ${entity_name}
 */
class ${common.to_camelcase(entity_name, True)}ServiceMongo extends BaseService {

    private $db_connection;
    private $db_collection;

    /**
     * Constructor
     */
    public function __construct()
    {
        $this->db_connection = new \MongoClient();
        $this->db_collection = $this->db_connection->${model['schema-name']}->${entity_name};
    }

	/**
	 * Returns list of the records.
	 *
	 * @param array $queryParams  Parameters used for querying
	 * @param int   $offset       The starting record
	 * @param int   $limit        Maximum number of records to retrieve
	 * @return Response
	 */
	public function list${common.to_camelcase(entity_name, True, True)}($queryParams, $offset = 0, $limit=100)
	{
		$criteria = array(); // The criteria
        $cursor = $this->db_collection->find( $criteria )->skip($offset)->limit($limit);

        $records = array();
        while ($cursor->hasNext())
        {
            $doc = $cursor->getNext();
            $record = $this->toModel($doc);
            $records[] = $record;
        }
		return $records;
	}

	/**
	 * Returns paginated list of the records.
	 *
	 * @param array $queryParams  Parameters used for querying
	 * @param int   $page_size    The max number of entries shown per page
	 * @return Response
	 */
	public function paginate${common.to_camelcase(entity_name, True, True)}($queryParams, $page_size = 20)
	{
	    // @TODO: pending
		$query = \${common.to_camelcase(entity_name, True)}::query();
		$query = $this->parseQueryParams($query, $queryParams);
        $records = $query->paginate($page_size);
		return $records;
	}

    /**
	 * Returns the count of records satisfying the critieria.
	 *
	 * @param array $queryParams  Parameters used for querying
	 * @return int number of records that satisfied the criteria
	 */
	public function count{common.to_camelcase(entity_name, True, True)}($queryParams)
	{
	    // @TODO: pending
	    $criteria = array();
		$count = $this->db_collection->find( $criteria )->count();
		return $count;
	}

	/**
	 * Creates a new records.
	 * Mostly wrapper around insert with pre and post processing.
	 *
	 * @param array $data  Parameters used for creating a new record
	 * @return mixed  null if successful, validation object validation fails
	 */
	public function create${common.to_camelcase(entity_name, True)}($data)
	{

		$validator = \${common.to_camelcase(entity_name, True)}::validator($data);
        if ($validator->passes()) {
            $record = new \${common.to_camelcase(entity_name, True)}();
            $record->fill($data);

            /*
             * @todo: assign default values as needed
             */
            $now = new \DateTime;
            $now_str = $now->format('Y-m-d H:i:s');
            $record->uuid = uniqid();
            $record->created_dt = $now_str;
            $record->updated_dt = $now_str;

            $this->db_collection->insert( $arrModel );

            return $record;
        } else {
            throw new ValidationException($validator);
        }
	}

	/**
	 * Retrieves a single record.
	 *
	 * @param  int $id  The primary key for the search
	 * @return ${common.to_camelcase(entity_name, True)}
	 */
	public function find${common.to_camelcase(entity_name, True)}($id)
	{
		$criteria = array( '_id' => new \MongoId($id) );
        $doc = $this->db_collection->findOne( $criteria );

        $record = null;
        if (!empty($doc))
        {
            $record = $this->toModel($doc);
        }

		return $record;
	}

	/**
	 * Update the specified resource in storage.
	 *
	 * @param  int   $id    The primary key of the record to update
	 * @param  array $data  The data of the update
	 * @return mixed null if successful, validation if validation error
	 */
	public function update${common.to_camelcase(entity_name, True)}($id, $data)
	{
		$validator = \${common.to_camelcase(entity_name, True)}::validator($data);
        if ($validator->passes()) {
            $record = $this->find${common.to_camelcase(entity_name, True)}($id);
            $record->fill($data);

            $now = new \DateTime;
            $now_str = $now->format('Y-m-d H:i:s');
            $record->updated_dt = $now_str;

            $arrModel = $record->toArray();
            $criteria = array( '_id' => new \MongoId($id) );
            $this->db_collection->update( $criteria, $arrModel );

            return $record;
        } else {
            throw new ValidationException($validator);
        }
	}

	/**
	 * Remove the specified resource from storage.
	 *
	 * @param  int  $id
	 * @return bool true if deleted, false otherwise
	 */
	public function destroy${common.to_camelcase(entity_name, True)}($id)
	{
		// delete
		$record = $this->find${common.to_camelcase(entity_name, True)}($id);
		if (!empty($record)) {
		    $criteria = array( '_id' => new \MongoId($id) );
		    $this->db_collection->remove( $criteria );
		    return true;
		}
		return false;

	}

	/**
	 * Returns the Laravel model object
	 */
    private function toModel($doc)
    {
        $model = new \${common.to_camelcase(entity_name, True)}();
        $model->sid = $doc['_id'];
        $model->fill($doc);
        return $model;
    }
}
% endfor
